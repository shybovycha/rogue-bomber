<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tamago</title>
</head>
<body>
  <canvas id="tamago"></canvas>

  <script>
    const canvas = document.querySelector('canvas#tamago');

    const ctx = canvas.getContext('2d');

    const TILE_HEIGHT = 16;
    ctx.font = `${TILE_HEIGHT}px courier new`;
    const TILE_WIDTH = ctx.measureText('X').width;

    const TILE_EMPTY = Symbol(0);
    const TILE_PERMANENT_WALL = Symbol(1);
    const TILE_BRICK_WALL = Symbol(2);
    const TILE_PLAYER = Symbol(3);
    const TILE_BOMB1 = Symbol(4);
    const TILE_BOMB2 = Symbol(5);
    const TILE_EXPLOSION = Symbol(6);
    const TILE_NEXT_LEVEL_DOOR = Symbol(7);

    const TILES = {
      [TILE_EMPTY]: ['.', '#b3b3b3'], // empty
      [TILE_PERMANENT_WALL]: ['#', '#a2a2a2'], // permanent wall
      [TILE_BRICK_WALL]: ['▒', '#b76014'], // '░' brick wall
      [TILE_PLAYER]: ['@', '#000'], // player
      [TILE_BOMB1]: ['ó', '#000'], // bomb
      [TILE_BOMB2]: ['Ó', '#000'], // bomb
      [TILE_EXPLOSION]: ['*', '#ff8920'], // explosion
      [TILE_NEXT_LEVEL_DOOR]: ['>', '#2edfdf'], // next level door
    };

    const KEY_MOVE_RIGHT = 72; // h
    const KEY_MOVE_LEFT = 74; // j
    const KEY_MOVE_UP = 75; // k
    const KEY_MOVE_DOWN = 76; // l
    const KEY_PLACE_BOMB = 32; // space

    const BOMB_TICK_INTERVAL = 700;
    const BOMB_TICK_TIME = 4100;
    const EXPLOSION_DURATION = 600;

    const AI_UPDATE_INTERVAL = 100;

    const LEVEL_ROWS = 15;
    const LEVEL_COLS = 11;

    const level = [];

    const COL_PADDING = 0;
    const ROW_PADDING = -1;

    const width = (TILE_WIDTH + COL_PADDING) * LEVEL_COLS;
    const height = (TILE_HEIGHT + ROW_PADDING) * (LEVEL_ROWS + 1);

    canvas.style.width = `${width * 2}px`;
    canvas.style.height = `${height * 2}px`;

    canvas.width = width;
    canvas.height = height;

    const player = {
      position: {
        x: 1,
        y: 1,
      },
      attributes: {
        hp: 3,
        speed: 1,
        bombs: 10,
        fires: 1,
      },
    };

    const nextLevelDoor = { x: -1, y: -1 };

    let bombs = {
      timers: new Set(),
      intervals: new Set(),
      explosionTimers: new Set(),
    };

    const bonuses = [];
    const enemies = [];

    const generateLevel = (rows, cols) => {
      player.position = { x: 1, y: 1 };

      bombs.timers.forEach(t => clearTimeout(t));
      bombs.intervals.forEach(t => clearInterval(t));
      bombs.explosionTimers.forEach(t => clearTimeout(t));

      bombs.timers.clear();
      bombs.intervals.clear();
      bombs.explosionTimers.clear();

      // clear level
      let emptySlots = 0;

      for (let i = 0; i < rows; ++i) {
        level[i] = [];

        for (let t = 0; t < cols; ++t) {
          if (i === 0 || t === 0 || i === rows - 1 || t === cols - 1 || ((i % 2) === 0 && (t % 2) === 0)) {
            level[i][t] = TILE_PERMANENT_WALL;
            continue;
          }

          level[i][t] = TILE_EMPTY;
          ++emptySlots;
        }
      }

      nextLevelDoor.x = -1;
      nextLevelDoor.y = -1;

      const walls = Math.floor(emptySlots / 3) + (Math.floor(Math.random() * 100) % (emptySlots / 3));

      let filled = 0;

      while (filled < walls) {
        const x = Math.floor(Math.random() * 100) % rows;
        const y = Math.floor(Math.random() * 100) % cols;

        // permanent walls must not be touched
        if (level[x][y] == TILE_PERMANENT_WALL) {
          continue;
        }

        // player starting positions must be clear
        if ((x == 1 && y == 1) || (x == 2 && y == 1) || (x == 1 && y == 2)) {
          continue;
        }

        if (nextLevelDoor.x === -1 || nextLevelDoor.y === -1) {
          nextLevelDoor.x = x;
          nextLevelDoor.y = y;
        }

        level[x][y] = TILE_BRICK_WALL;
        ++filled;
      }
    };

    const movePlayer = (dx, dy) => {
      // check for collisions
      let { position: { x, y } } = player;

      x += dx;
      y += dy;

      const cell = level[x][y];

      if (cell === TILE_NEXT_LEVEL_DOOR) {
        generateLevel(LEVEL_ROWS, LEVEL_COLS);
        render();
        return;
      }

      if ([ TILE_BRICK_WALL, TILE_PERMANENT_WALL, TILE_BOMB1, TILE_BOMB2 ].includes(cell)) {
        return;
      }

      player.position = { x, y };
    };

    const explodeBomb = (x, y) => {
      const EXPLOSION_STOPPER_TILES = [TILE_BRICK_WALL, TILE_BOMB1, TILE_BOMB2, TILE_EXPLOSION];

      const { fires } = player.attributes;

      const explosionFires = [{ x, y }];

      for (let i = x - 1; i > -1 && i > x - 1 - fires; --i) {
        if (level[i][y] === TILE_PERMANENT_WALL) {
          break;
        }

        explosionFires.push({ x: i, y });

        if (EXPLOSION_STOPPER_TILES.includes(level[i][y]) || (player.position.x === i && player.position.y === y)) {
          break;
        }
      }

      for (let i = x + 1; i < level.length && i < x + 1 + fires; ++i) {
        if (level[i][y] === TILE_PERMANENT_WALL) {
          break;
        }

        explosionFires.push({ x: i, y });

        if (EXPLOSION_STOPPER_TILES.includes(level[i][y]) || (player.position.x === i && player.position.y === y)) {
          break;
        }
      }

      for (let i = y - 1; i > -1 && i > y - 1 - fires; --i) {
        if (level[x][i] === TILE_PERMANENT_WALL) {
          break;
        }

        explosionFires.push({ x, y: i });

        if (EXPLOSION_STOPPER_TILES.includes(level[x][i]) || (player.position.x === x && player.position.y === i)) {
          break;
        }
      }

      for (let i = y + 1; i < level[0].length && i < y + 1 + fires; ++i) {
        if (level[x][i] === TILE_PERMANENT_WALL) {
          break;
        }

        explosionFires.push({ x, y: i });

        if (EXPLOSION_STOPPER_TILES.includes(level[x][i]) || (player.position.x === x && player.position.y === i)) {
          break;
        }
      }

      for (let { x: cx, y: cy } of explosionFires) {
        level[cx][cy] = TILE_EXPLOSION;

        if (level[cx][cy] === TILE_BOMB1 || level[cx][cy] === TILE_BOMB2) {
          explodeBomb(cx, cy);
        }
      }

      render();

      const t2 = setTimeout(() => {
        bombs.explosionTimers.delete(t2);

        // clear explosion fires
        for (let { x: cx, y: cy } of explosionFires) {
          if (cx === nextLevelDoor.x && cy === nextLevelDoor.y) {
            level[cx][cy] = TILE_NEXT_LEVEL_DOOR;
          } else {
            level[cx][cy] = TILE_EMPTY;
          }
        }

        render();
      }, EXPLOSION_DURATION);

      bombs.explosionTimers.add(t2);
    };

    const placeBomb = () => {
      const { position: { x, y }, attributes: { bombs: maxBombs } } = player;

      if (bombs.timers.size >= maxBombs) {
        return;
      }

      level[x][y] = TILE_BOMB1;

      let state = TILE_BOMB1;

      const t1 = setInterval(() => {
        if (state === TILE_BOMB1) {
          state = TILE_BOMB2;
        } else {
          state = TILE_BOMB1;
        }

        level[x][y] = state;

        render();
      }, BOMB_TICK_INTERVAL);

      const t2 = setTimeout(() => {
        explodeBomb(x, y);
        clearInterval(t1);
        bombs.intervals.delete(t1);
        bombs.timers.delete(t2);
      }, BOMB_TICK_TIME);

      bombs.intervals.add(t1);
      bombs.timers.add(t2);
    };

    const initInput = () => {
      document.addEventListener('keydown', (e) => {
        // console.log('keypress', e);

        const keyCodes = {
          [KEY_MOVE_RIGHT]: () => movePlayer(0, -1),
          [KEY_MOVE_LEFT]: () => movePlayer(1, 0),
          [KEY_MOVE_UP]: () => movePlayer(-1, 0),
          [KEY_MOVE_DOWN]: () => movePlayer(0, 1),
          [KEY_PLACE_BOMB]: () => placeBomb(),
        };

        const fn = keyCodes[e.keyCode];

        if (fn) {
          fn.call(null);
          render();
        }
      });
    };

    const initAI = () => {
      setInterval(updateAI, AI_UPDATE_INTERVAL);
    };

    const updateAI = () => {};

    const renderTile = (x, y, tile) => {
      const [ char, style ] = TILES[tile];

      ctx.clearRect(y * (TILE_WIDTH + COL_PADDING), x * (TILE_HEIGHT + ROW_PADDING), (TILE_WIDTH + COL_PADDING), (TILE_HEIGHT + ROW_PADDING));

      ctx.font = `${TILE_HEIGHT}px courier new`;
      ctx.fillStyle = style;
      ctx.fillText(char, y * (TILE_WIDTH + COL_PADDING), (x + 1) * (TILE_HEIGHT + ROW_PADDING));
    };

    const render = () => {
      ctx.clearRect(0, 0, width, height);

      // renderLevel();
      for (let i = 0; i < level.length; ++i) {
        for (let t = 0; t < level[i].length; ++t) {
          renderTile(i, t, level[i][t]);
        }
      }

      renderTile(player.position.x, player.position.y, TILE_PLAYER);
    };

    generateLevel(LEVEL_ROWS, LEVEL_COLS);
    initInput();
    initAI();
    render();
  </script>
</body>
</html>